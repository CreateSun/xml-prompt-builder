<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🐛 Nested Drop Bug Investigation</title>
    <style>
        body { font-family: 'Courier New', monospace; padding: 20px; background: #fff5f5; }
        .bug-alert { background: #ffebee; border: 3px solid #f44336; padding: 20px; margin: 20px 0; border-radius: 8px; }
        .code-analysis { background: #f5f5f5; border-left: 4px solid #ff6600; padding: 15px; margin: 15px 0; font-family: monospace; }
        .scenario { background: white; border: 2px solid #666; padding: 15px; margin: 15px 0; border-radius: 6px; }
        .fix { background: #e8f5e8; border: 2px solid #4caf50; padding: 15px; margin: 15px 0; border-radius: 6px; }
        .tree { font-family: monospace; margin: 10px 0; line-height: 1.6; }
        .depth-0 { padding-left: 0px; }
        .depth-1 { padding-left: 24px; }
        .depth-2 { padding-left: 48px; }
        .depth-3 { padding-left: 72px; }
        .problem { color: #f44336; font-weight: bold; }
        .solution { color: #4caf50; font-weight: bold; }
    </style>
</head>
<body>
    <div class="bug-alert">
        <h1>🐛 NESTED DROP BUG IDENTIFIED</h1>
        <p><strong>Issue:</strong> Elements disappear when dropped as nested on the last element</p>
        <p><strong>Root Cause:</strong> Multiple bugs in nested drop handling logic</p>
    </div>

    <div class="scenario">
        <h2>🔍 Bug Scenario Analysis</h2>
        
        <h3>Problem Case: Drop as nested on last element</h3>
        <div class="tree">
            <div class="depth-0">📄 document (index 0)</div>
            <div class="depth-1">📝 section-1 (index 1)</div>
            <div class="depth-1">📝 section-2 (index 2) ← LAST ELEMENT</div>
            <div style="color: red;">🎯 Try to drop "section-1" as nested under "section-2"</div>
        </div>
        
        <p><strong>Expected Result:</strong> section-1 becomes child of section-2</p>
        <p class="problem"><strong>Actual Result:</strong> section-1 disappears! 💥</p>
    </div>

    <div class="bug-alert">
        <h2>🚨 Bug #1: findLastChildIndex Logic</h2>
        
        <div class="code-analysis">
            <strong>Current Broken Code:</strong><br>
            <pre>function findLastChildIndex(flatElements, parentId) {
  let lastChildIndex = flatElements.findIndex(el => el.id === parentId);
  
  for (let i = lastChildIndex + 1; i < flatElements.length; i++) {
    if (flatElements[i].ancestorIds.includes(parentId)) {
      lastChildIndex = i;
    } else {
      break;
    }
  }
  
  return lastChildIndex;
}</pre>
        </div>
        
        <p><strong>Problem:</strong> When dropping on the last element with no children, this returns the parent's own index, not where children should be inserted!</p>
        
        <h3>🧪 Test Case Walkthrough:</h3>
        <ol>
            <li>flatElements = [document, section-1, section-2]</li>
            <li>Dropping section-1 as child of section-2 (last element)</li>
            <li>findLastChildIndex(flatElements, 'section-2')</li>
            <li>lastChildIndex = 2 (section-2's own index)</li>
            <li>Loop starts at i=3, but array.length=3, so loop never runs</li>
            <li>Returns 2 (section-2's index)</li>
            <li>insertIndex = 2 + 1 = 3</li>
            <li>But we also remove section-1 (index 1), shifting everything!</li>
            <li>Result: insertion at wrong position → element disappears</li>
        </ol>
    </div>

    <div class="bug-alert">
        <h2>🚨 Bug #2: Index Shifting Logic</h2>
        
        <div class="code-analysis">
            <strong>Problematic Logic:</strong><br>
            <pre>// Current logic for handling index shifts
if (draggedIndex < insertIndex) {
  const elementsToRemoveCount = 1 + draggedDescendants.length;
  insertIndex -= elementsToRemoveCount;
}</pre>
        </div>
        
        <p><strong>Problem:</strong> This adjustment doesn't account for the specific case where we're inserting at the very end of the array after removing elements!</p>
    </div>

    <div class="scenario">
        <h2>🔬 Detailed Bug Reproduction</h2>
        
        <h3>Step-by-Step Failure Analysis:</h3>
        <div class="tree">
            <strong>Initial State:</strong><br>
            <div class="depth-0">0: document</div>
            <div class="depth-1">1: section-1 ← DRAGGING THIS</div>
            <div class="depth-1">2: section-2 ← DROP TARGET (nested)</div>
        </div>
        
        <ol>
            <li><strong>findLastChildIndex('section-2'):</strong> returns 2 (section-2's own index)</li>
            <li><strong>insertIndex calculation:</strong> 2 + 1 = 3</li>
            <li><strong>draggedIndex < insertIndex?</strong> 1 < 3 = true</li>
            <li><strong>Adjust insertIndex:</strong> 3 - 1 = 2</li>
            <li><strong>Remove section-1:</strong> array becomes [document, section-2]</li>
            <li><strong>Insert at index 2:</strong> tries to insert at array.length, but...</li>
            <li class="problem"><strong>FAILURE:</strong> Element gets lost in the insertion logic!</li>
        </ol>
    </div>

    <div class="fix">
        <h2>✅ THE FIXES NEEDED</h2>
        
        <h3>Fix #1: Correct findLastChildIndex Logic</h3>
        <div class="code-analysis">
            <strong>Fixed Logic:</strong><br>
            <pre>function findLastChildIndex(flatElements, parentId) {
  const parentIndex = flatElements.findIndex(el => el.id === parentId);
  if (parentIndex === -1) return -1;
  
  let lastChildIndex = parentIndex; // Start with parent's index
  
  // Look for children AFTER the parent
  for (let i = parentIndex + 1; i < flatElements.length; i++) {
    if (flatElements[i].ancestorIds.includes(parentId)) {
      lastChildIndex = i;
    } else {
      break; // No more children
    }
  }
  
  // Return the position where new child should be inserted
  // If no children exist, insert right after parent
  return lastChildIndex;
}</pre>
        </div>
        
        <h3>Fix #2: Better Index Management</h3>
        <div class="code-analysis">
            <strong>Improved Logic:</strong><br>
            <pre>// More robust insertion index calculation
case 'child':
  const lastChildIndex = findLastChildIndex(flatElements, targetId);
  insertIndex = lastChildIndex + 1;
  
  // Special handling for end-of-array insertions
  if (insertIndex > flatElements.length) {
    insertIndex = flatElements.length;
  }
  break;</pre>
        </div>
        
        <h3>Fix #3: Safer Element Removal</h3>
        <div class="code-analysis">
            <strong>Defensive Programming:</strong><br>
            <pre>// Add validation to ensure elements aren't lost
const originalLength = result.length;
result.splice(insertIndex, 0, ...updatedElementsToMove);

// Validate the operation succeeded
if (result.length !== originalLength) {
  console.log('✅ Elements properly inserted');
} else {
  console.error('❌ Element insertion failed!');
}</pre>
        </div>
    </div>

    <div class="fix">
        <h2>🎯 Expected Fix Results</h2>
        
        <div class="tree">
            <strong>After Fix - Correct Behavior:</strong><br>
            <div class="depth-0">📄 document</div>
            <div class="depth-1">📝 section-2</div>
            <div class="depth-2">📝 section-1 ← CORRECTLY NESTED!</div>
        </div>
        
        <ul>
            <li>✅ Elements no longer disappear</li>
            <li>✅ Nested drops work on last element</li>
            <li>✅ Robust index calculation</li>
            <li>✅ Proper parent-child relationships</li>
        </ul>
    </div>

    <script>
        console.log('🐛 Nested Drop Bug Investigation');
        console.log('🚨 Found: findLastChildIndex returns wrong position for childless elements');
        console.log('🚨 Found: Index shifting logic fails for end-of-array insertions');
        console.log('✅ Solution: Fix both functions with robust error handling');
        
        // Simulate the bug
        function brokenFindLastChildIndex(elements, parentId) {
            let lastChildIndex = elements.findIndex(el => el.id === parentId);
            
            for (let i = lastChildIndex + 1; i < elements.length; i++) {
                // This loop never runs when parent is last element!
                console.log('Loop iteration:', i);
            }
            
            return lastChildIndex; // Returns parent's own index!
        }
        
        // Test with last element
        const testElements = [
            { id: 'doc', ancestorIds: [] },
            { id: 'sec1', ancestorIds: ['doc'] },
            { id: 'sec2', ancestorIds: ['doc'] }
        ];
        
        const result = brokenFindLastChildIndex(testElements, 'sec2');
        console.log('❌ Broken result for last element:', result, '(should be position for new child)');
    </script>
</body>
</html>